# UDML Schema Standardization Proposal

## Executive Summary

After reviewing UDML YAML files generated by 7 different LLMs (Claude Sonnet 4.5, GPT-5, GPT-5 Codex, GPT-5 Mini, Claude Sonnet 4.5 Haiku, Gemini 2.5 Pro, and Grok Code Fast 1), we identified significant variations in structure, naming conventions, and schema representation. This proposal establishes a standardized UDML schema that balances human readability, machine parseability, and comprehensive coverage of the 6 UDML domains.

## Analysis of Variations Found

### 1. File Naming Conventions
- **Variations**: `abk-agent.udml.yaml`, `abk.agent.udml.yaml`, `abk-agent.yaml`, `abk_agent.yml`
- **Standardization Decision**: Use kebab-case with `.udml.yaml` extension: `abk-agent.udml.yaml`
- **Rationale**: Hyphen-separated naming is most readable and consistent with YAML file naming conventions

### 2. Top-Level Structure
- **Variations**: Some files use direct domain keys (`information:`, `access:`), others wrap in `udml:` or `provides:` containers
- **Standardization Decision**: Use direct domain keys at top level for simplicity
- **Rationale**: Reduces nesting complexity while maintaining clarity

### 3. Schema Representation
- **Variations**: JSON Schema style, custom type notation (`list<type>`), simple key-value pairs, Rust-style types
- **Standardization Decision**: Use simplified JSON Schema with custom extensions for component references
- **Rationale**: JSON Schema is widely understood, extensible, and machine-parseable

### 4. Metadata Inclusion
- **Variations**: Some include `metadata:`/`meta:` sections, others omit them
- **Standardization Decision**: Include standardized metadata block
- **Rationale**: Provides essential context and versioning information

### 5. Domain Coverage Depth
- **Variations**: From high-level descriptions to detailed technical specifications
- **Standardization Decision**: Require structured entries with `id`, `description`, and `schema`/`rules` fields
- **Rationale**: Ensures consistency while allowing appropriate detail levels

## Standardized UDML Schema Specification

### File Structure Template

```yaml
# UDML Specification for [component-name]
# [Brief description of component's role]

# Required metadata
id: component-name
layer: runtime|infrastructure|boundary|support|plugin
ownership: crate|wasm|external
version: "1.0"
summary: One-sentence description of component purpose

# Core UDML domains (all required, but may be empty arrays)
information:     # Real world state and persistent semantic domain data
access:         # Permissible ways data may be viewed/read
manipulation:   # Lawful mutation rules
extract:        # Derivation of new representations
movement:       # How data travels through processes and boundaries
coordination:   # Synchronization and orchestration primitives

# Optional sections
dependencies:   # Runtime and build dependencies
risks:         # Known risks and mitigations
```

### Domain Specifications

#### Information Domain
Defines canonical data structures and their schemas.

```yaml
information:
  - id: data-structure-name
    kind: struct|enum|alias|collection|blob|stream
    description: "Purpose and context of this data structure"
    schema:
      type: object
      properties:
        field_name:
          type: string|integer|boolean|array|object
          description: "Field purpose"
      required: [field1, field2]
    owners: [component-ids]  # Components that own/manage this data
```

#### Access Domain
Defines permissible read/view operations and their constraints.

```yaml
access:
  - id: access-rule-name
    target: information-id  # Reference to information entry
    description: "What this access rule allows"
    read: component-id|public|private  # Who can read
    constraints: []  # Additional constraints (optional)
```

#### Manipulation Domain
Defines lawful mutation operations.

```yaml
manipulation:
  - id: mutation-name
    target: information-id
    kind: create|update|delete|invalidate
    description: "What this mutation does"
    preconditions: []  # Required conditions
    postconditions: [] # Guaranteed outcomes
    side_effects: []   # Indirect effects (optional)
```

#### Extract Domain
Defines data transformation and derivation operations.

```yaml
extract:
  - id: transform-name
    inputs: [information-ids]
    output: information-id
    method: algorithm|template|aggregation|inference
    description: "How the transformation works"
```

#### Movement Domain
Defines data flow between components and external systems.

```yaml
movement:
  - id: route-name
    direction: in|out|bi
    from: component-id|external
    to: component-id|external
    medium: memory|wasm-call|fs|network|process|stdout|stderr
    payload: information-id|stream
    trigger: event|schedule|mutation|request
    reliability: best-effort|at-least-once|exactly-once
    description: "Context of data movement"
```

#### Coordination Domain
Defines synchronization and orchestration primitives.

```yaml
coordination:
  - id: primitive-name
    kind: orchestration|scheduling|locking|retry|checkpoint|classification
    participants: [component-ids]
    drives: [movement-route-ids]
    description: "How coordination works"
```

### Naming Conventions

- **Component IDs**: kebab-case (e.g., `abk-agent`, `umf-chatml`)
- **Data Structure IDs**: kebab-case (e.g., `agent-config`, `session-state`)
- **Rule/Operation IDs**: kebab-case (e.g., `read-session`, `append-message`)
- **References**: Use `#` prefix for internal references (e.g., `#/information/agent-config`)

### Required vs Optional Fields

- **Required**: `id`, `layer`, `ownership`, `version`, `summary`, all 6 domain arrays
- **Optional**: Domain array entries, `dependencies`, `risks`, detailed schema properties

## Example Implementation: abk-agent

```yaml
id: abk-agent
layer: runtime
ownership: crate
version: "1.0"
summary: Core agent runtime that orchestrates all components and manages session lifecycle

information:
  - id: agent-config
    kind: struct
    description: "Runtime configuration for agent behavior and limits"
    schema:
      type: object
      properties:
        max_iterations: { type: integer, minimum: 1 }
        enable_streaming: { type: boolean }
        timeout_seconds: { type: integer, minimum: 1 }
        session_id: { type: string, pattern: "^[a-zA-Z0-9-]+$" }
      required: [max_iterations, enable_streaming, timeout_seconds]
    owners: [abk-agent]

  - id: agent-state
    kind: struct
    description: "Current execution state including message history and session data"
    schema:
      type: object
      properties:
        messages: { type: array, items: { $ref: "#/definitions/InternalMessage" } }
        session_id: { type: string }
        iteration_count: { type: integer, minimum: 0 }
        last_checkpoint: { type: string, format: date-time }
        phase: { type: string, enum: [init, classify, plan, act, reflect, done, error] }
      required: [messages, session_id, iteration_count]
    owners: [abk-agent]

access:
  - id: read-agent-state
    target: agent-state
    description: "Read current agent execution state for monitoring and debugging"
    read: abk-orchestration|abk-checkpoint
    constraints: []

manipulation:
  - id: append-message
    target: agent-state
    kind: update
    description: "Add new message to conversation history"
    preconditions: []
    postconditions: [message-added-to-history]
    side_effects: [checkpoint-triggered]

extract:
  - id: extract-tool-calls
    inputs: [agent-state]
    output: tool-call-list
    method: algorithm
    description: "Extract tool invocation requests from assistant messages"

movement:
  - id: config-from-cli
    direction: in
    from: abk-cli
    to: abk-agent
    medium: memory
    payload: agent-config
    trigger: initialization
    reliability: exactly-once
    description: "Receive configuration from CLI at startup"

  - id: messages-to-provider
    direction: out
    from: abk-agent
    to: abk-provider
    medium: memory
    payload: agent-state
    trigger: orchestration
    reliability: at-least-once
    description: "Send conversation context to LLM provider"

coordination:
  - id: session-orchestration
    kind: orchestration
    participants: [abk-agent, abk-provider, cats, abk-executor]
    drives: [messages-to-provider, tool-results-from-cats]
    description: "Coordinate the complete agent workflow from message input to response generation"
```

## Migration Guidelines

### For Existing Files
1. **Rename files** to use `.udml.yaml` extension and kebab-case naming
2. **Add metadata block** with required fields
3. **Restructure domains** to use standardized format
4. **Convert schemas** to simplified JSON Schema style
5. **Add missing domains** with empty arrays if not applicable

### Validation Checklist
- [ ] File follows `component-name.udml.yaml` naming
- [ ] Contains required metadata fields
- [ ] All 6 domains present (even if empty)
- [ ] Schema references use consistent format
- [ ] IDs follow kebab-case convention

## Benefits of Standardization

1. **Interoperability**: Consistent structure enables automated processing and comparison
2. **Maintainability**: Clear conventions reduce cognitive load for developers
3. **Tooling Support**: Standardized format enables UDML-specific tools and validation
4. **Documentation**: Uniform structure improves readability across components
5. **Evolution**: Established patterns make schema updates predictable

This standardized schema provides a solid foundation for UDML adoption while maintaining flexibility for component-specific needs.</content>
<parameter name="filePath">docs/UDML/schema-standardization-response.md